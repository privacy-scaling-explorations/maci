---
title: MACI Process Messages Circuit
description: Introduction to the core zk-SNARK circuits of MACI
sidebar_label: Process Messages Circuit
sidebar_position: 3
---

[**Repo link**](https://github.com/privacy-scaling-explorations/maci/blob/dev/circuits/circom/core)

This circuit allows the coordinator to prove that they have correctly processed each message in reverse order, in a consecutive batch of 5 ^ msgBatchDepth messages to the respective state leaf within the state tree. Coordinators would use this circuit to prove correct execution at the end of each Poll.

The [`processMessages`](https://github.com/privacy-scaling-explorations/maci/blob/dev/circuits/circom/core/qv/processMessages.circom) circuit will try to decrypt the messages, and based on the content of the message, update within itself the trees, to generate a proof that the coordinator's off-chain processing was done correctly. In other words, the circuit takes a final state, an initial state, and the leaves (messages and user signups) - it processes these messages via the different state transitions to finally check that the expected state is correct.
The pre-requisites for this circuit are:

- the related Poll has ended
- the state tree has been merged
- the message tree has been merged

This circuit requires the coordinator's private key, hence a proof for this circuit can only be generated by the coordinator. The private key is needed in order to generate the ECDH shared key used to decrypt the messages.

![ProcessMessages](/img/circuits/processMessages_2_0.svg)

:::info
A version working with non quadratic voting (non-qv) is also [available](https://github.com/privacy-scaling-explorations/maci/blob/dev/circuits/circom/core/non-qv/processMessages.circom). This version is called `processMessagesNonQV` and is to be used when the Poll is not using the quadratic voting feature. Note that by default MACI works with quadratic voting.
:::

#### Parameters

| #   | Parameter                | Description                                          |
| --- | ------------------------ | ---------------------------------------------------- |
| 0   | State tree depth         | Allows $(2^{n})$ signups.                            |
| 1   | Message tree depth       | Allows $(5^{n})$ votes or key-change messages.       |
| 2   | Message batch tree depth | Allows $(5^{n})$ messages to be processed per batch. |
| 3   | Vote option tree depth   | Allows $(5^{n})$ vote options.                       |

#### Inputs

| Input signal                     | Description                                                                             |
| -------------------------------- | --------------------------------------------------------------------------------------- |
| `inputHash`                      | The SHA256 hash of inputs supplied by the contract                                      |
| `packedVals`                     | Described below                                                                         |
| `pollEndTimestamp`               | The Unix timestamp at which the poll ends                                               |
| `msgRoot`                        | The root of the message tree                                                            |
| `msgs`                           | The batch of messages as an array of arrays                                             |
| `coordinatorPubKeyHash`          | $poseidon_2([cPk_x, cPk_y])$                                                            |
| `inputBatchHash`                 | The value of $chainHash$ at the beginning of batch                                      |
| `outputBatchHash`                | The value of $chainHash$ at the end of batch                                            |
| `newSbCommitment`                | Described below                                                                         |
| `coordPrivKey`                   | The coordinator's private key                                                           |
| `coordPubKey`                    | The coordinator's public key                                                            |
| `encPubKeys`                     | The public keys used to generate shared ECDH encryption keys to encrypt the messages    |
| `currentStateRoot`               | The state root before the commands are applied                                          |
| `currentStateLeaves`             | The state leaves upon which messages are applied                                        |
| `currentStateLeavesPathElements` | The Merkle path to each incremental state root                                          |
| `currentSbCommitment`            | Described below                                                                         |
| `currentSbSalt`                  | Described below                                                                         |
| `newSbCommitment`                | Described below                                                                         |
| `newSbSalt`                      | Described below                                                                         |
| `currentBallotRoot`              | The root of the ballot tree before messages are applied                                 |
| `currentBallots`                 | The ballots upon which ballots are applied                                              |
| `currentBallotsPathElements`     | The Merkle path to each incremental ballot root                                         |
| `currentVoteWeights`             | The existing vote weight for the vote option in the ballot which each command refers to |
| `currentVoteWeightsPathElements` | The Merkle path from each vote weight to the vote option root in its ballot             |

##### `inputHash`

All inputs to this circuit are private except for `inputHash`. To save gas during verification, the `MessageProcessor` contract hashes the following values using SHA256 and uses the hash as the sole element of $ic$:

1. `packedVals`
2. `coordinatorPubKeyHash`
3. `outputBatchHash`
4. `currentSbCommitment`
5. `newSbCommitment`
6. `actualStateTreeDepth`

The hash is computed using the `sha256` Solidity function and is then subject to modulo $p$.

##### `packedVals`

`packedVals` is the following values represented as one field element. Consider that a field element is roughly 253 bits. The big-endian bit-representation is as such:

| Bits        | Value                      |
| ----------- | -------------------------- |
| 1st 53 bits | `0`                        |
| 2nd 50 bits | `batchEndIndex`            |
| 3rd 50 bits | `currentMessageBatchIndex` |
| 4th 50 bits | `numSignUps`               |
| 5th 50 bits | `maxVoteOptions`           |

For instance, if `maxVoteOptions` is 25 and `batchEndIndex` is `5`, and all other values are 0, the following is the `packedVals` representation in hexadecimal:

`140000000000000000000000000000000000019`

##### `currentSbCommitment` and `newSbCommitment`

The `currentSbCommitment` is the $poseidon_3$ hash of the state tree root, the ballot tree root, and a random salt. The purpose of the random salt, which should be unique to each batch, is to ensure that the value of `currentSbCommitment` always changes even if all the commands in a batch are invalid and therefore do not change the state tree or ballot tree root.

The result of applying a batch of messages to `currentSbCommitment` is `newSbCommitment`.

##### `currentSbSalt`

The salt used to produce `currentSbCommitment` (see above).

##### `newSbSalt`

The salt used to produce `newSbCommitment` (see above).

#### Statements that the circuit proves

1. That the prover knows the preimage to `inputHash` (see above)
2. That the prover knows the preimage to `currentSbCommitment` (that is, the state root, ballot root, and `currentSbSalt`)
3. That `maxVoteOptions <= (5 ^ voteOptionTreeDepth)`
4. That `numSignUps <= (2 ^ stateTreeDepth)`
5. That `coordPubKey` is correctly derived from `coordPrivKey`
6. That `coordPubKey` is the preimage to the Poseidon hash of `coordPubKey` (provided by the contract)
7. That each message in `msgs` exists in the message tree
8. That after decrypting and applying each message, in reverse order, to the corresponding state and ballot leaves, the new state root, new ballot root, and `newSbSalt` are the preimage to `newSbCommitment`
9. That the starting and ending message chain hashes match input and output batch chain hashes
